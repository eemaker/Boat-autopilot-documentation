\section{Software implementation}
\label{sec:software_implementation}
The following sections detail the software implementation of the system. Each class is described in terms of its responsibilities and usage. Code examples are given where it was deemed relevant, but the full code base can be found as a seperate item in the appendix, and a generated code documentation (doxygen) is also included.

\subsection{Autopilot}
The Autopilot is made up of two separate PID loops which were implemented using the MiniPID library \cite{minipid}. It allows for setting output limits, which are setup in the constructor of the Autopilot as seen in listing~\ref{lst:autopilot_con}. It can also be seen that the PID terms are all set to -1, this is used to indicate an invalid value. There is only one set of PID terms because terms for the thruster were not parameterized out to the website. Therefore some relaxed values are set, so the motor is not going to accelerate too much. 

\begin{lstlisting}[caption = {Constructor method of the Autopilot}, captionpos=b, label={lst:autopilot_con}, language=C++,firstnumber=1]
Autopilot::Autopilot(IPositionMotor& rudder, ISpeedMotor& thruster): rudder_pid_(0, 0, 0), thruster_pid_(1,0,0), rudder_(rudder), thruster_(thruster)
{
	max_speed_ = 10; //in km/h
	p_ = -1; //Invalid value
	i_ = -1; //Invalid value
	d_ = -1; //Invalid value
	thruster_pid_.setOutputLimits(0, 20); //Hardcoding limits, maybe this should be done through the user interface
	rudder_pid_.setOutputLimits(48, 76);  //A servo has diffuculties at the edges ei. 0 and 90 so it is limited

	thruster_pid_.setPID(0.01,0,0);

}
\end{lstlisting}

The Autopilot works by setting the rudder and thruster PWM outputs from a calculation done by the MiniPID library. For the rudder the the setpoint is always 0, since the navigation outputs which direction to steer. The thruster has a setpoint of the max speed set in the constructor, and it also gets its error from the navigation. The navigation calls the \texttt{Run} function in the autopilot with a NMEA telegram, the autopilot can parse either a APB or a VTG telegram. The APB telegram includes the direction to steer, and the VTG holds current speed of the boat. 

It was decided that stopping the boat just means to stop the motor and center the rudder. 

Before the \texttt{Run} function will work, there needs to have been a call to the \texttt{SetParameters} function, which sets the rudder PID terms. 

\subsection{JSONReceiver}
The responsibility of the JSONReciever is to get the activeParam.JSON, and the toNav.JSON files and parse them. After parsing it needs to call the appropriate functions in other objects to let them know of this new data. To handle the JSON format in C++ the "json for modern c++" library by Niels Lohmann was used\cite{json}. 

Reading the toNav.json file is done by reading the contents of file, and parsing it into JSON, after this it needs to figure out what kind of task is in the file. This is done by first using the json find function on the parsed json object. If the task is either none, stop, start, just the task is passed on to the Navigation via the PerformTask function. If the task is calcCoverage, it goes through and checks if the toNav protocol is adhered to. If everything checks out, it creates a CoverageRectangle object which is then passed on to the Navigation together with the task, through the PerformTask function.
The exact same thing happens with the calcP2P task, but it creates a TargetPosition object instead.

To receive the active parameter profile, the JSONReceiver parses the activeParam.json file with the "json for modern c++" library like before. Then it reads all the information and assigns it to the proper variables, so it can send to the Navigation and Autopilot, through the SetParameters function in both of them.

\subsection{JSONTransmitter}
The  JSONTransmitter class is responsible for collecting information from the motors, navigation, and gps modules, translate it to valid JSON format, and then update the fromNav.json file. To handle JSON format parsing in C++, the "JSON for modern C++" library by Niels Lohmann was used\cite{json}. 

Because the Transmitter and the Navigation are mutually dependent, the Transmitter class has a pointer function that is called by the Navigation in its constructor, passing the Transmitter a this-pointer to the Navigation object. The Navigation itself has a reference to the JSONTransmitter.

The Transmitter is called by the Navigation when a task has been performed, and is given a timestamp parameter. It then collects NavigationData from the Navigation class, MotorStatuses from the two motors, and a GPSStatus from the gps. From this it builds a JSON "tree" of objects, and packages them correctly, taking edge cases into account as defined by the fromNav.json protocol. 

Listing~\ref{lst:TransmitFromNav} shows the final few lines of the TransmitFromNav function, where the fromNav JSON is assembled and overwrites the contents of the fromNav.json file.

\begin{lstlisting}[caption = {Last lines of the TransmitFromNav function in the Transmitter class}, captionpos=b, label={lst:TransmitFromNav}, language=C++,firstnumber=1]
//Construction of fromNav JS object
nlohmann::json fromNav;

fromNav["Completed_path_"] = nlohmann::json::parse(iterator_completed_path_string);
fromNav["Path_"] = nlohmann::json::parse(iterator_path_string);
fromNav["Status_"] = nlohmann::json::parse(status_str);
fromNav["Telemetry_"] = telemetry;
fromNav["Progress_"] = progress;
fromNav["Timestamp_"] = nlohmann::json::parse(timestamp);

//Dump of fromNav JS object to local file at the specified path
std::ofstream file(filepath_ + "fromNav.json");
file << fromNav.dump();
\end{lstlisting}

\subsection{Navigation}
The Navigation class is responsible for performing tasks given by the user, calculating paths, and starting/stopping. To do this, it uses a number of algorithms, calls the GPS for new data, and finally transmits data back to the user as well as sending data to the autopilot if a path is being traversed.

The two path types used in this project are a simple line to a destination called a "point to point" path, and a more complicated "coverage rectangle" which, as the name implies, covers an area.

The first consideration in any navigation system is to decide how to treat straight lines on a non-planar surface. The standard approach for maps is to use the Mercator Projection, which is what is commonly seen on any 2D world map. This type of projection is favoured in many places because of the rectangular, well-behaved, result. However, projecting the earth down in this fashion does present some challenges, the most important for our project being that seemingly equally long lines on the map are in fact almost never of equal length. The Mercator projection maps are stretched by a factor that increases with the absolute latitude, meaning that the closer you get to the poles, the smaller distances are.

The system has to take this into account, and there are multiple approaches to dealing with this issue. The common approach by freight ships is to use great circle lines, treating the earth as a spheroid and find the best "great circle" to get between two points. As one would expect, these lines are distorted when they undergo a Mercator projection. 

In our project, the goal is not to get from A to B as quickly as possible, but to be able to map an area of the sea and give the user/client an intuitive user interface to input the desired area to map. 

This makes great circle paths ill-suited as a way of treating the globe. The user should not have to think about the implementation of the system, but just define an area, in our case a rectangle, to map. For this reason, a way of navigating that produces straight lines when Mercator projected is necessary. These types of lines on a spheroid are called rhumb lines, and the difference between the great circle and rhumb lines can be seen in figure ~\ref{fig:rhumbgreatcirclemercator} below.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{Images/Implementation/Rhumb_vs_great_circle_mercator_projection}
\caption{A comparison of rhumb lines and great circle lines after mercator projection \cite{rhumb-greate-cirle}}
\label{fig:rhumbgreatcirclemercator}
\end{figure}

As seen, the rhumb line is straight while the great circle line is curved. In the real world though, the situation is reversed, and the rhumb line will be longer than the great circle line. This disparity is not a problem for our uses, since we're interested in mapping, and not getting somewhere as efficiently as possible. 

The navigation unit uses the GeographicLib library to calculate rhumb lines and rhumb distances. Initially, an algorithm was written by the devleopment team to do this, but after comparing it to the one offered in the Geographic library, the performance and precision was much better, and it was decided to use the library for these two functions, and for importing the WGS84 constants. All other Navigation algorithms and calculations have been designed, developed, and tested by the project team.

The full calculation of a point to point path is seen below in listing ~\ref{lst:setspeed}, with "..." indicating a new function is called, or the root function is returned to.

\begin{lstlisting}[caption = {Function responsible for calculating a P2P path}, captionpos=b, label={lst:calculateP2PPath}, language=C++,firstnumber=1]
std::vector<Coordinate> Navigation::calculateP2PPath(const TargetPosition target_position)
{
	//The path_ and completed_path_ lists are first emptied
	path_ = {};
	completed_path_ = {};

	//The current coordinate is extracted from the GPS
	const Coordinate start = gps_.GetPose().Coordinate_;

	//The target coordinate is extracted from the TargetPosition input
	const std::vector<Coordinate> end = {target_position.get_target_postion()};

	//Construct the path_ object as a list of the 
	const std::vector<Coordinate> path_segments = calculatePathSegments(start, end, 0);
...
std::vector<Coordinate> Navigation::calculatePathSegments
(const Coordinate current_position, const std::vector<Coordinate> key_method_positions, const int method) const
{
	switch (method)
	{
	case 0: //Point to Point
		{
			//Create the point to point segment vector, insert current position and end position
			std::vector<Coordinate> point_to_point_segments = std::vector<Coordinate>{current_position, key_method_positions[0]};

			//Return the current position and the end position.
			return point_to_point_segments;
		}
...
	//Translate the segments to points
	const std::vector<Coordinate> path = calculatePointsFromSegments(path_segments, 1);
...
std::vector<Coordinate> Navigation::calculatePointsFromSegments(std::vector<Coordinate> path_segments,const int method)const
{
	//Create the path vector
	std::vector<Coordinate> path = { { path_segments.front().Latitude_, path_segments.front().Longitude_ } };

	switch (method)
	{
	case 0: //Point to Point
	{
		GeographicLib::Rhumb rhumb(GeographicLib::Constants::WGS84_a(), GeographicLib::Constants::WGS84_f());
		double s12, azi12;
		rhumb.Inverse(path_segments.front().Latitude_, path_segments.front().Longitude_, path_segments.back().Latitude_,
			path_segments.back().Longitude_, s12, azi12);
		const GeographicLib::RhumbLine line = rhumb.Line(path_segments.front().Latitude_, path_segments.front().Longitude_,
			azi12);

		// Nominal distance between points
		const double ds0 = parameters_.distance_between_points_;

		// The number of intervals
		const int num = int(ceil(s12 / ds0));

		// Use intervals of equal length
		const double ds = s12 / num;

		for (int i = 1; i <= num; ++i)
		{
			double lat, lon;
			line.Position(i * ds, lat, lon);
			if (path.back().Latitude_ != lat || path.back().Longitude_ != lon) //Check for duplicates
			{
				path.push_back(Coordinate(lat, lon));
			}
		}
		break;
	}
	...
	//Update path_. This is important for the public GetNavData function,
	// and in case the trip is stopped and then resumed at some point
	path_ = path;
	
	return path;
}
\end{lstlisting}

As seen in the source code, the general idea is to create a rhumb line between the current coordinate and the target position, and then sample the rhumb line with the distance_between_points_ variable. Figure~\ref{fig:p2p_path} below shows the UI when a point to point path has been calculated, and figure~\ref{fig:p2p_path_traversed} shows the point to point path and the part of the path that has already been completed.

\begin{figure}[H]
\centering
\includegraphics[max width=0.9\linewidth]{Images/Implementation/P2P_path_being_traversed}
\caption{A calculated point to point path being traversed in the UI}
\label{fig:p2p_path}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[max width=0.9\linewidth]{Images/Implementation/P2P_path_calculated}
\caption{A calculated point to point path in the UI}
\label{fig:p2p_path_traversed}
\end{figure}

The equivalent process cannot be applied to the coverage rectangle of course, since the goal is the map the specified area. It was decided early on that the project would not incorporate general polygon coverage, since this topic is vastly complicated, and would require much more development time. The problem was instead simplified to deal only with rectangular areas.

An area is mapped by defining a tool width, the width of the mapping tool used, or just the desired sampling of the area, and then drawing parallel lines over the coverage area seperated by this tool width. 

The CoverageRectangle case in calculatePathSegments thus calculates the start and end points of these lines. It was chosen that each line would have a constant latitude to ease this process, but had the project been further developed, perhaps it could have been made possible to rotate this rectangle. Between these parallel lines, the boat must turn pi radians and get onto another line. This was done by connecting the parallel lines with half spheres at the ends in a sensible manner, and deal with all the edge cases this creates. 

The calculatePointsFromSegments for the CoverageRectangle case samples between the parallel lines, and adds some points found on a half circle between the endpoints. It also checks whether the tool_width and total latitude difference divide nicely, and if not, changes its route slightly at the start of the coverage rectangle to correct for this. An example of a drawn coverage rectange in the UI can be seen in figure ~\ref{fig:coverage_rectangle_path}. A zoomed-in version of the end of this coveragerectangle can be seen in figure ~\ref{fig:coverage_rectangle_path_zoom}.

\begin{figure}[H]
\centering
\includegraphics[max width=0.9\linewidth]{Images/Implementation/Coverage_rectangle_on_map}
\caption{A calculated coverage rectangle path in the UI}
\label{fig:coverage_rectangle_path}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[max width=0.9\linewidth]{Images/Implementation/Coverage_rectangle_on_map_zoom}
\caption{A zoomed-in calculated coverage rectangle path in the UI}
\label{fig:coverage_rectangle_path_zoom}
\end{figure}

As seen, the parallel lines are all connected as desired, and the endpoint is reached.

Apart from calculating these paths, the navigation is also responsible for calculate data for the autopilot when the task is "start" indicating that the user wants to traverse a calculated path. It outputs this information in the NMEA format describes in the protocol section. The data is which way to turn to reach the next waypoint, which waypoint is next, how many degrees must be turned, the cross track error, and other (less important) information.

The bearings and which way to turn is simply calculated by comparing the angle between the previous and next point, and the orientation, or absolute heading, of the boat itself. Calculating the cross track error is a more challenging process, and the navigation section will conclude with a short description of how it is obtained. 

The cross track error and important metrics used in the navigation algorithm that calculates it is seen in figure ~\ref{fig:xte}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{Images/Implementation/xte}
\caption{Calculating the cross track error}
\label{fig:xte}
\end{figure}

As seen, the cross track error is the distance between the boat and the line connecting the previous and next point on the path. The algorithm to calculate the xte first finds the distance between the boat and the next waypoint, indicated by "a". This distance is then traversed by rhumb lines in both directions from the next waypoint relative to the line connecting the previous and next point. 

This line must necessarily contain the global minimum for the xte of the boat, since it cannot possibly have an xte higher than the distance to the next waypoint. The algorithm sets the xte to this distance + 1, just to get a "too high" value, and then iterates through the line, updating the xte if the rhumb distance from any point is lower than the current xte. 

When this algorithm has been run, the value in the xte variable is necessarily the correct value, with the accuracy given by the distance_between_xte_points_ member.

\subsection{DCMotor}
The DCMotor class is responsible for controlling and regulating a DC Motor using a gpio pin on the controller. The speed percentage of the motor is a double between 0 and 100, which is translated into a Hardware PWM on the gpio pin in the \texttt{SetSpeed} function as seen in listing~\ref{lst:setspeed}. 

\begin{lstlisting}[caption = {Function responsible for DC Motor speed percentage to hardware PWM translation}, captionpos=b, label={lst:setspeed}, language=C++,firstnumber=1]
void DCMotor::SetSpeed(const double speed)
{
	if (speed < 0)
	{
		speed_ = 0;
	}
	else if (speed > 100)
	{
		speed_ = 100;
	}
	else
	{
		//Save position set
		speed_ = speed;
	}
	gpio_.GpioHardwarePWM(pin_,frequency_, static_cast<unsigned>(speed_* 10000));
}
\end{lstlisting}

As seen, the percentage speed is multiplied by a factor of 10000 and then cast, then finally used as an argument in the gpio GpioHardwarePWM function call, along with a pin number and a frequency. Aside from this, the DC Motor acts as a MotorStatusGetter when called by the JSONTransmitter, and return a MotorStatus object with information about the percentage of the motor and the motor type (in this case a SPEED motor in the MotorType enumerator).

\subsection{Servo}
The Servo class has responsibility of controlling any kind of servo via a GPIO pin. To set the position of the motor it takes a position described as a percentage ei. a double between 0-100. To move a servo from one extremity to the other, it does not require a duty-cycle from 0-100, but instead a period lenght between 500 µs and 2500 µs\cite{pigpio}. Therefore the percentage needs to be converted and this is done in the helper function \texttt{percentageToServo} as seen in listing~\ref{lst:percent2servo}. To set the GPIO pin to the correct period the \texttt{GpioServo} function is used, which is a wrapper function for the pigpio library\cite{pigpio}.

\begin{lstlisting}[caption = {Percentage to servo periode convertion function}, captionpos=b, label={lst:percent2servo}, language=C++,firstnumber=1]
//Coverts a percentage into the right value for the servo
unsigned Servo::percentageToServo(const double percentage) const
{
	//Starts servo pulses on the GPIO, 0 (off), 500 (most anti-clockwise) to 2500 (most clockwise). 
	double x = 500 + percentage / 100 * (2000); 
	return static_cast<unsigned>(x);
}
\end{lstlisting}

\subsection{Ublox-neo7m}
The Ublox-neo7m is a GPS receiver by ublox, and it follows the NMEA protocol. This means that it sends out a serial telegram. To get this telegram from a serial device the simpleSerial library is used\cite{simple_serial}. The Ublox class has two responsibilities, it needs to get the concrete gps data, and then it needs to allow other classes to get pose data, speed, and status data. 

To make sure that this class is never blocking the execution of other functions by waiting for GPS data. It has the Setup function which returns a thread that runs the function getGPSData. This function keeps reading from the serial device, and when it gets a GGA telegram it parses it in to a Pose, and a bunch of variables needed for a GPSStatus object. It also parses the VTG telegram since it contains the speed of the GPSReciever. 

The GPS receiver outputs the latitude and longitude in a different format then what the rest of the system uses, there for it is converted with a helper function \texttt{convert\-Degree\-Minutes\-2\-Degrees}. To convert from \texttt{ddmm.mmmm} the format the rest of the system is using, this formula can be used \texttt{ddd + mm.mmmm/60}\cite{convertion}. The implementation of this formula can be seen in listing~\ref{lst:convertion}.


\begin{lstlisting}[caption = {Convertion between latitude longitude formats}, captionpos=b, label={lst:convertion}, language=C++,firstnumber=1]
double Ublox_neo7m::convertDegreeMinutes2Degrees(std::string degree_minutes) const
{
	//Find the . to be used as a fixed point
	const int delimtIndex = degree_minutes.find(".");
	
	//Extract ddd from start of string on til 2 before the .
	int ddd;
	try
	{
		ddd = std::stoi(degree_minutes.substr(0, delimtIndex - 2));
	}
	catch (...)
	{
		ddd = 0;
	}
	
	//The rest is mm
	double mm;
	try
	{
		mm = std::stod(degree_minutes.substr(delimtIndex - 2, degree_minutes.length() - 1));
	}
	catch (...)
	{
		mm = 0;
	}
	
	//return the convertion
	return ddd + mm / 60;
}
\end{lstlisting}

\subsection{User interface}
To develop the user interface for the project it was decided that to get the most flexibility it should be made as a website. To design the website the Bootstrap toolkit \cite{bootstrap}. This allows an easy creation of a simple design.
The design is build up of a simple side menu, with a logo and the menu items. Beside the menu is the context of the active menu. In figure~\ref{fig:frontpage} the active page is the front page.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{Images/Implementation/frontpage}
\caption{Website front page}
\label{fig:frontpage}
\end{figure}

In figure~\ref{fig:p2ppage} it can be seen how the website handles categorization of functionality. In the figure there is a Coordinate panel which hold two more fields, one for latitude and longitude. Also there is a panel with the estimated time en-route, and buttons to control the boat. The coordinate panel and Controls panel are also encapsulated in a box, which is besides a box with a map panel in it. This structure is created to make the website more size flexible, and it clearly defines different areas of interest.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{Images/Implementation/p2p_page}
\caption{Website Point to point page}
\label{fig:p2ppage}
\end{figure}

Apart for the design of the website, it is develop with AngularJS\cite{angular}, which is a JavaScript framework. It makes data binding very easy, also it allows the website to only load once, after this the context is just changed. This context changing makes it very easy to develop different parts of the website separately, and still retain no page loading.

\subsubsection{Edit parameters}
The edit parameters page need to be able to create, delete, edit and active parameter profiles. A parameter profile is a JSON object containing different parameters, it is the same as the active parameter profile, which is describe in the section~\ref{sec:active_param}.

A list of all of these parameter profiles is first loaded into a variable, if there are any. These parameter profiles comes from a file called profiles.json. When the user clicks the "New" button it create a default profile and pushes it to the list of profiles, and subsequently saves the list to the profiles.json file, as seen in listing~\ref{lst:newprofile}. 

\begin{lstlisting}[caption = {NewProfile function in editParam.js}, captionpos=b, label={lst:newprofile}, language=C++,firstnumber=1]
 $scope.NewProfile = function() {
    //Creates a new default profile and appends it to the list of Profiles_
    $scope.Profiles_.push({
      name_: "New Profile",
      parameter_names_: [
        "P", "I", "D", "Tool Width"
      ],
      parameters_: [
        0, 0, 0, 0
      ],
      creation_timestamp_: Date.now()
    });
    saveToFile("profiles", $scope.Profile_data_); //Sending the content to the server to get saved.
    $scope.Selected_profile_ = $scope.Profiles_[($scope.Profiles_).length - 1]; // Selects the new profile in the ui
  }
\end{lstlisting}

If the user presses the "Delete" button with a parameter profile selected, it will get deleted if there is not currently a profile open in the editor. If the profile being deleted is the active on, then the active one is replaces with an empty profile called None. When the profile is deleted from the list, then the list is saved to the profiles.json file, the source code can be seen in listing~\ref{lst:deleteprofile}

\begin{lstlisting}[caption = {DeleteProfile function in editParam.js}, captionpos=b, label={lst:deleteprofile}, language=C++,firstnumber=1]
 $scope.DeleteProfile = function(index) {
     if ($scope.Editing_profile_ != true) { //Checks to make sure you are not deleting the profile that's currently being edited
 
 		if($scope.Profiles_[index] == $scope.Active_profile_ ){
 			$scope.Active_profile_ = {
 		      name_: "None",
 		      creation_timestamp_: Date.now()
 		    }
 			saveToFile("active", $scope.Active_profile_);
 		}
 
 	  $scope.Profiles_.splice(index, 1) //Removes one element from the list at index
 
       if (index < 1) {
         $scope.Selected_profile_ = $scope.Profiles_[0];
       } else {
         $scope.Selected_profile_ = $scope.Profiles_[index - 1]; //Selects the profile under the one deleted.
       }
 
       saveToFile("profiles", $scope.Profile_data_); //Sending the content to the server to get saved.
     } else {
 
     }
   }
\end{lstlisting}

Pressing the "Edit" button changes a boolean that reveals a edit section. Two variables are updated first the \texttt{Profile\_} is updated with the values of the profile selected in the list of profiles. After this the \texttt{Profile_} is copied in to the \texttt{Revert\_profile\_}, this makes sure that the staring values are kept track of, if the user at a later point wants to revert. The exact sequence of the EditProfile function can be seen in listing~\ref{lst:editprofile}.

\begin{lstlisting}[caption = {EditProfile function in editParam.js}, captionpos=b, label={lst:editprofile}, language=C++,firstnumber=1]
$scope.EditProfile = function(index) {
    if ($scope.Editing_profile_ != true && ($scope.Profiles_).length > 0) { //Makes sure that there is something to edit!
      $scope.Revert_profile_ = {}; //Makes sure a Revet_profile_ exists
      $scope.Profile_ = $scope.Profiles_[index];
      angular.copy($scope.Profile_, $scope.Revert_profile_); //Creates a copy of Profile_ into Revert_profile_ instead of reference
      $scope.Editing_profile_ = true; //turns on the panel in the ui.
    }
  }
\end{lstlisting}

When the edit section is visible the user can change any of the variables, when happy with the changes the user can press the "Save" button. This hides the edit section and saves the list of profiles to the profiles.json file. But from the code in listing~\ref{lst:saveprofile} it is not apparent how the \texttt{Profile\_} variable is saved. This is because JavaScript always handles copying variables by reference, so \texttt{Profiles\_} is a reference to one position in the list of profiles. And when saving the list it is already updated.

\begin{lstlisting}[caption = {SaveProfile function in editParam.js}, captionpos=b, label={lst:saveprofile}, language=C++,firstnumber=1]
$scope.SaveProfile = function() {
    $scope.Editing_profile_ = false; //Turning of the panel in the ui for editing
    $scope.Editing_profile_name = false; //makeing sure that the edit name ui change is reset.
    saveToFile("profiles", $scope.Profile_data_); //Sending the content to the server to get saved.
  }
\end{lstlisting}

Say the user was not happy with the changes, the "Revert" button can be pressed. This goes through all the parameters in the profile and overrides their values and and names with what they were when the "Edit button was pressed, this sequence can be seen in listing~\ref{lst:revertprofile}.

\begin{lstlisting}[caption = {RevertProfile function in editParam.js}, captionpos=b, label={lst:revertprofile}, language=C++,firstnumber=1]
$scope.RevertProfile = function() {
    //Deep copy of only the things that we want to revert
    $scope.Revert_profile_.parameters_.forEach(function(param, index) {
      $scope.Profile_.parameter_names_[index] = $scope.Revert_profile_.parameter_names_[index];
      $scope.Profile_.parameters_[index] = $scope.Revert_profile_.parameters_[index];
    })
  }
\end{lstlisting}

The last button not explained is the "Activate" button. When the user presses the button, the selected profile should be set active. Being active means that the name of the profile is displayed next to "Active Profile:" and that the profile and its content is saved to the activeParam.json file. The simple function can be seen in listing~\ref{lst:activeparam}.

\begin{lstlisting}[caption = {ActivateProfile function in editParam.js}, captionpos=b, label={lst:activeparam}, language=C++,firstnumber=1]
$scope.ActivateProfile = function(index) {
    $scope.Active_profile_ = $scope.Profiles_[index]; //Sets active profile to be the profile at index in the list Profiles_
    saveToFile("active", $scope.Active_profile_); //Sending the content to the server to get saved.
  }
\end{lstlisting}

Many of the function discussed save variables to different files, this is done through the \texttt{saveToFile} function. This function makes a POST call to the server. This POST call includes the data to save, any kind of JSON variable, it also needs a url. The url is used by the server to figure out what to do with the data, this is explained in more detail in section~\ref{sec:nodejs_server} \nameref{sec:nodejs_server} on page~\pageref{sec:nodejs_server}. The syntax for sending a POST call with Angular, can be seen in listing~\ref{lst:savetofile}.

\begin{lstlisting}[caption = {saveToFile function in editParam.js}, captionpos=b, label={lst:savetofile}, language=C++,firstnumber=1]
saveToFile = function(url, content) {
	$http.post(url, angular.toJson(content)). //Build a http POST call with the url and content
	then(function(data, status, headers, config) {}) //We do not handle errors atm.
}
\end{lstlisting}

All of this functionality is data binded and wrapped into the website, an example can be seen in figure~\ref{fig:editpage}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{Images/Implementation/edit_page}
\caption{The Edit parameter page of the website}
\label{fig:editpage}
\end{figure}

\subsubsection{Point to point}

The Point to point page consists of 2 sections one with the coordinates and controls and one with map, this can be seen in figure~\ref{fig:p2ppage}. The map is a leaflet map, but since the website is built with AngularJS, a special leaflet map is one called angular-leaflet-directive\cite{leaflet}. 

For the point to point page, the map need to be able to display a marker of the boat and one for where the user wants the boat to go. Also the website need to be able to draw a path, calculated by the navigation. There for the map is setup with marker that takes the boats boats position, and one that starts out being invisible for the position where the user wants the boat to go. The user can either click the map or, input coordinates directly in the input fields. What ever the user chooses the updateEndCoord function is called, this function show in listing~\ref{lst:updateendcoord}, takes the position inputted. It then assigns it to the marker on the map, since the markers position is data bound to the input fields it automatically update. Also the marker is set to be visible 

\begin{lstlisting}[caption = {updateEndCoord in p2p.js}, captionpos=b, label={lst:updateendcoord}, language=C++,firstnumber=1]
updateEndCoord = function(end_coord) {
        if (end_coord.lat != undefined) {
            $scope.Cached_data_.markers_p2p_[1].lat = end_coord.lat;
        }
        if (end_coord.lng != undefined) {
            $scope.Cached_data_.markers_p2p_[1].lng = end_coord.lng;
        }
        $scope.Cached_data_.markers_p2p_[1].opacity = 1;
    }
\end{lstlisting}

To make sure that the boat position is always up to date, a loop is created from where all other functions are called. This can be seen in listing~\ref{lst:getData}. Every second the function getDataFromNav is called which get the content of the fromNav file which contains the GPS coordinates for the boat, and much more. The boat pose is then updated on the map.

\begin{lstlisting}[caption = {Updating the boat pose in p2p.js}, captionpos=b, label={lst:getData}, language=C++,firstnumber=1]

let main_interval_ = 1000; //The interval for getting new navData

let main_promise = $interval(function() {
        getDataFromNav("../savedData/fromNav.json");
    }, main_interval_); //Update frequency for the boat data

...

getDataFromNav = function(path) {
        return $http.get(path).then(function(response) {
            //Parse fromNav.json, add telemetry data
            updateBoatPose(response.data.Telemetry_);
            $scope.Cached_data_.Path_ = response.data.Path_;
        }).catch(function(data) {
            $scope.Cached_data_.Boat_pose_ = {
                //Default boat position, for testing purposes
                latitude_: 0,
                longitude_: 0,
                orientation_: 0
            };
        });
    }
    
...

updateBoatPose = function(pose) {
        $scope.Cached_data_.Boat_pose_ = pose;
        //Boat marker, set to the boats current position
        $scope.Cached_data_.markers_p2p_[0].lat = pose.latitude_
        $scope.Cached_data_.markers_p2p_[0].lng = pose.longitude_
        $scope.Cached_data_.markers_p2p_[0].iconAngle = pose.orientation_
    }
\end{lstlisting}

When a position on the map has been chosen and boat position is updated. The user can press the "Calculate path" button which call the Action function this function is in charge of change the state of the button as well as sending right task to the navigation. Since this is the first time the User presses the button, it changes it look to reflect that it is calculating, and then function calculatePath is called. This function builds the JSON object that should be send to the navigation, when it has been saved. It calls the function waitForPath, as seen in listing~\ref{lst:calcPath}. In side the waitForPath function an asynchronous loop is setup and constantly getting the data from the navigation. 

\begin{lstlisting}[caption = {calculatePath and waitForPath in p2p.js}, captionpos=b, label={lst:calcPath}, language=C++,firstnumber=1]
calculatePath = function(end_coord) {
        saveToFile("toNav", {
            "func_": "calcP2P",
            "target_position_": {
                latitude_: end_coord.lat,
                longitude_: end_coord.lng
            }
        });
        //Wait for navigation unit to send a new path
        waitForPath();
        //Return when the Path object has been updated by the controller
    }

    waitForPath = function() {
        let current_timestamp = $scope.Cached_data_.Path_.timestamp_;
        $scope.waitForPathPromise = $interval(function() {
            getDataFromNav("../savedData/fromNav.json");
            $http.get("../savedData/fromNav.json").then(function(response) {
                $scope.Cached_data_.Path_ = response.data.Path_;
		if (current_timestamp < $scope.Cached_data_.Path_.timestamp_) {
			$interval.cancel($scope.waitForPathPromise);
                	$scope.Cached_data_.action_state_p2p_ = 1;
		 	setPath(response.data.Path_.line_)
			$scope.Action();
                }
            });
        }, wait_for_path_interval_); //Update frequency for the boat data
    }
\end{lstlisting}

When the waitForPath function get data from the navigation it calls the setPath function, which is show in listing~\ref{lst:setpath}. setPath takes the data from the navigation and displays it on the map as a blue line. After the path is drawn it calls the Action function, which now changes the button state to be start.

\begin{lstlisting}[caption = {setPath in p2p.js}, captionpos=b, label={lst:setpath}, language=C++,firstnumber=1]
setPath = function(path) {
		$scope.Cached_data_.paths_p2p_.p2.latlngs.splice (0,$scope.Cached_data_.paths_p2p_.p2.latlngs.length);
		//Run through all elements in the path and overwrite what is in the paths_ object
		for (let i = 0; i < path.length; i++) {
			$scope.Cached_data_.paths_p2p_.p2.latlngs[i] = {
				lat: path[i].latitude_,
				lng: path[i].longitude_
			}
		}
	}
\end{lstlisting}

When the user presses the start button the Action function is called. The action state dictates that the start function should be called.  The website save a start task in the toNav.json file, then it calls the waitForCompletion function, as seen in listing~\ref{lst:start}. Which starts an asynchronous loop that read the data in fromNav.json. With this data it updates the progress and ETE, as well as displaying the completed path on the map as a green line. 

\begin{lstlisting}[caption = {the start and waitForCompletion functions in p2p.js}, captionpos=b, label={lst:start}, language=C++,firstnumber=1]
    //Send command to navigation unit
    start = function() {
        saveToFile("toNav", {
            "func_": "start"
        });
        $scope.Cached_data_.ETE_.class_p2p_ = "progress-bar"
        //Wait for navigation unit to send a new path
        waitForCompletion()
        //Return when the path has been traversed
    }

    waitForCompletion = function() {
        $scope.Cached_data_.ETE_.time_p2p_ = "Calculating ...";
        $scope.waitForCompletionPromise = $interval(function() {
            if ($scope.Cached_data_.ETE_.progress_p2p_ >= 100) {
                $scope.Cached_data_.ETE_.time_p2p_ = "Arrived at target";
                $scope.Cached_data_.ETE_.class_p2p_ = "progress-bar-success"
                $scope.Cached_data_.action_state_p2p_ = 3;
                saveToFile("toNav", {
                    "func_": "none"
                });
                $scope.Action()
                $interval.cancel($scope.waitForCompletionPromise);
            } else {
                getDataFromNav("../savedData/fromNav.json");
                $http.get("../savedData/fromNav.json") .then(function(response) {
					$scope.Cached_data_.ETE_.progress_p2p_ = response.data.Progress_.percentage_;
                    $scope.Cached_data_.ETE_.time_p2p_ = response.data.Progress_.ete_;
                    setCompletedPath(response.data.Completed_path_.line_);
                })
            }
        }, wait_for_completion_interval_)
    }
\end{lstlisting}

At any point in time the user can press the "Stop" button which call the Stop function. It sends a stop task to the navigation through the toNav.json file, seen in listing~\ref{lst:stop}. Also the Stop function updates some visuals, for example it makes the progress bar red, and makes the ETE say "Canceled".

\begin{lstlisting}[caption = {Stop function in p2p.js}, captionpos=b, label={lst:stop}, language=C++,firstnumber=1]
    $scope.Stop = function() {
            //Reset action state and destroy both waiting promises if they exist
            $scope.Cached_data_.action_state_p2p_ = 0;
            if ($scope.waitForPathPromise) {
                $interval.cancel($scope.waitForPathPromise);
            }
            if ($scope.waitForCompletionPromise) {
                $interval.cancel($scope.waitForCompletionPromise);
            }
            $timeout.cancel($scope.p2ptimeout);
            $scope.Cached_data_.action_p2p_ = {
                text_: "Calculate Path",
                class_: "btn-warning",
                icon_: "glyphicon glyphicon-flash"
            }
    
            //Update command file
            saveToFile("toNav", {
                "func_": "stop"
            });
    
            $scope.Cached_data_.action_state_p2p_ = 0
            $scope.Cached_data_.ETE_.time_p2p_ = "Canceled";
            $scope.Cached_data_.ETE_.class_p2p_ = "progress-bar-danger"
        }
\end{lstlisting}

\subsubsection{Coverage}
Coverage is in many ways the same as point to point, the only real difference is that it uses 2 makers instead of two. Using two makers means that it needs to create a different task to send to the navigation, an example of this creation can be seen in listing~\ref{lst:coveragerectangle}.


\begin{lstlisting}[caption = {CoverageRectangle creation in  coverage.js}, captionpos=b, label={lst:coveragerectangle}, language=C++,firstnumber=1]
calculatePath = function(end_coord) {
        saveToFile("toNav", {
            "func_": "calcP2P",
            "target_position_": {
                latitude_: end_coord.lat,
                longitude_: end_coord.lng
            }
        });
        //Wait for navigation unit to send a new path
        waitForPath();
        //Return when the Path object has been updated by the controller
    }
\end{lstlisting}

The visual design is also almost the same as point to point, but as explained there are two points. The coverage map represent the two markers with some similar looking ones, where they are labeled 1 and 2. The labeling is to indicate where the boat is going to start and end. In figure~\ref{fig:coveragepage}, a orange rectangle is also highlighting the area that has been covered by the points. 

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{Images/Implementation/coverage_page}
\caption{Visual design of the coverage page}
\label{fig:coveragepage}
\end{figure}


\subsubsection{Status}
The status page is used to display diagnostics data. The diagnostics data comes from the navigation part of the system, where gps data and motor status' are handles. The status page is implemented to specify the exact data it wants to display, but instead dynamically read from the fromNav.JSON file. In this file there is a javascript list named \texttt{Status\_} which holds any amount of generic status objects. This protocol is described in detail in section ~\ref{sec:protocol_fromNav} on page ~\pageref{sec:protocol_fromNav}. Because this javascript list can hold any number of objects, the status page can display any number of items. 

To display all of the status messages, it need somewhere to put it, there for in the HTML of the page a \texttt{<div>} tag is data bound to a variable. If the variable contains HTML it will get displayed, the HTML syntax can be seen in listing~\ref{lst:statushtml}.

\begin{lstlisting}[caption = {Html for displaying status'}, captionpos=b, label={lst:statushtml}, language=C++,firstnumber=1]
<div class="col-lg-5 col-md-offset-025 panel panel-default">
 <div class="panel-body">
     <div ng-bind-html="Status_panels_">
     </div>
		<div class="panel panel-default">
         <div class="panel-heading">
             <h3 class="panel-title">Update</h3>
         </div>
         <div class="panel-body">
             <div class="alert" ng-class="Time_since_last_data_.warning_" style=" display:inline-block; padding-top=1em">
                 <strong>Info:</strong> Time since last status message: {{Time_since_last_data_.time_}} s<br />
             </div>
         </div>
     </div>
 </div>
</div>
\end{lstlisting}

When the data from the fromNav.JSON file has been loaded, the updateStatusDisplay function is called with the javascript list \texttt{Status_}, and the timestamp of when the fromNav.JSON file was created. As it can be seen in listing~\ref{lst:statusjs}, the code runs through all of the status items, and takes the relevant data, and encloses it in the necessary HTML. When the HTML is built for all of \texttt{Status_} it is assigned to the \texttt{div} tag from the html. It is important to notice that the code explicitly tells Angular that it can trust the HTML just created as HTML. This has to be done to tell Angular that we are sure that cross site scripting isn't possible with this HTML. 

\begin{lstlisting}[caption = {displaying status messages }, captionpos=b, label={lst:statusjs}, language=C++,firstnumber=1]
updateStatusDisplay = function(status, timestamp) {
        let html = ""; //Creates a variable containing the html
        status.forEach(function(current_value) {
			//For each status object it creates a panel with the necessary data
            html += `
      <div class="panel panel-default">
      	<div class="panel-heading">
      		<h3 class="panel-title">` + current_value.title_ + `</h3>
      		</div>
      		<div class="panel-body">`;

            current_value.items_.forEach(function(item) {
                html += "<strong>" + item.title_ + ":</strong> " + item.data_ + " " + item.unit_ + "<br />"
                if (item.unit_ == '%') {
                    html += `<div class="progress">
                  			<div class="progress-bar ` + item.color_ + `  " role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: ` + item.data_ + `%">
                  			</div>
                  		</div>`;
                }
            });

			//Adds ending html
            html += `
      		</div>
      	</div>
      </div>`
        })
        $scope.Status_panels_ = $sce.trustAsHtml(html); //Sets the panels to the html created and trusts it, maybe not good for security

		//Updates the time size last data panel.
        $scope.Time_since_last_data_.time_ = Math.round((Date.now() - timestamp) / 1000);
        if ($scope.Time_since_last_data_.time_ > 20) {
            $scope.Time_since_last_data_.warning_ = "alert-danger";
        } else if ($scope.Time_since_last_data_.time_ > 10) {
            $scope.Time_since_last_data_.warning_ = "alert-warning";
        } else {
            $scope.Time_since_last_data_.warning_ = "alert-info";
        }


    };
\end{lstlisting}

The status page also has a Map just like the point to point page and coverage page. On the status page, only the boat position is displayed. The final visual design of the status page can be seen in figure~\ref{fig:statuspage}. It is some example diagnostics data, which is very like the data got from the navigation.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{Images/Implementation/status_page}
\caption{Visual design for displaying diagnostics data on the status page}
\label{fig:statuspage}
\end{figure}


\subsection{Node.js server}
\label{sec:nodejs_server}
The Nodejs server can be thought of as the back-end of the website, it is what needs to run for the website to be live. Nodejs is a javascript runtime\cite{nodejs}. This project uses the server to handle three of post calls that the client can make through the website, and also hosting the website on port 80. 

When a post call comes from the client with either a "/profiles", "/active" or "/toNav" url, the server takes the data it gets and writes it to the appropriate file, lets take "/profiles" as an example, The node package fs, is used to save the data to the profiles.json file in the savedData folder in the website, as seen in listing~\ref{lst:post}. After the file is saved then it returns a status 200, if it did not work it returns a status 500, which is a server error.

\begin{lstlisting}[caption = {Handeling a POST call to url "/profiles"}, captionpos=b, label={lst:post}, language=C++,firstnumber=1]
app.post('/profiles',function(req, res){
	console.log(req.body);
	res.set("Connection", "close");
	res.setHeader('Content-Type', 'application/json');

	fs.writeFile(website_path+'/savedData/profiles.json', JSON.stringify(req.body), function(err) {
	    if(err) {
			res.sendStatus(500);
	        return console.log(err);
	    }
	});
	res.sendStatus(200);

});
\end{lstlisting}

To host the website, the server is listening for a client, and if one connects the server, serves the client with the website. This can be seen in listing~\ref{lst:host}.

\begin{lstlisting}[caption = {Hosting server}, captionpos=b, label={lst:host}, language=C++,firstnumber=1]
app.use(express.static(website_path))

...

//wait for a connection
app.listen(80, function () {
  console.log('Server is running. Point your browser to: '+ip.address()+':80');
});
\end{lstlisting}


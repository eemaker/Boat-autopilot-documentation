%I konklusionen gives en samlet konklusion på projektarbejdet og procesarbejdet. Hvad er lykkedes, hvad er ikke lykkedes og hvad er årsagen til dette. Konklusionen skal indeholde et klart budskab og forholde sig objektivt til de krav, der er opstillet i projektet og de resultater som I har opnået. Det er vigtigt at konklusionen hænger sammen med problemformuleringen og den skal give svar på de spørgsmål, som er opstillet for projektet. Derkan med fordel konkluderes på MOSCOW-beskrivelsen i kravspecifikationen, hvis denne form for beskrivelse har været anvendt. Afsnittet skal desuden sammenfatte de slutninger, der kan drages af de resultater, som er omtalt i rapportens tidligere afsnit. Disse slutninger kan være såvel positive som negative. I skal ikke undlade at undertrykke de negative fund – har en metode f. eks. vist sig uegnet, bør det opfattes og fremhæves som et bidrag til ens erfaringsmateriale, og ikke skjules som et personligt nederlag. I konklusionen trækkes desuden de store linjer op. Væsentlige kvantitative resultater kan nævnes, hvorimod den detaljerede redegørelse og diskussion henvises til det foregående afsnit ”Diskussion af resultater”. Endelig skal der konkluderes på de vigtigste erfaringer fra selve processen. Som helhed skal konklusionerne, både den samlede konklusion og de individuelle konklusioner, være objektive og baseret på facts. Som helhed skal konklusionen være objektiv og baseret på facts.
\newpage
\chapter{Conclusion}
The goal of the project was to develop an autonomous boat for surveying the sea floor. Commands were to be sent through a UI, and the system should then internally figure out how to execute the given task. 

The components and libraries chosen for the project turned out to generally be well-suited to their purposes. 

Bootstrap enabled the team to quickly set up a good-looking intuitive UI, and later integration with Leaflet and hosting with NodeJS turned a potentially daunting website and server design task into something much more manageable. 

PiGpio and MiniPID saved a lot of time during the Autopilot development, and the function calls on the DCMotor and Servo classes, but some issues had to be solved in setting these up. 

The JSON parser created by Niels Lohmann was effective in parsing the JSON format, despite some functionality that was not implemented by the author of the library. 

GeographicLib made the navigation code slightly faster than it would have been with the team's own rhumb line algorithm, which is the only functionality that was imported from this library. 

C++11 functions were used throughout the controller system, and the team members gained more insight about the new developments in the C++ standard this way.

The system is able to navigate between waypoints defined by which method the user chooses in the UI. The user can see the diagnostics in the corresponding page, and the technician or user can modify the parameters as well. The point to point page allows the user to quickly calculate and start traversing a route to the destination, as well as stop the system in case of emergency, or simply wishing to go elsewhere. Finally, the rectangle coverage functionality allows the user to travse a selected area on the map with a toolwidth chosen in the parameter menu. The system thus fulfills all requirements for the UI. 

The NodeJS server hosts the website, and handles http requests from the website, reading or modifying the data files as needed. This is  

The system is also compatible with, and uses, the NMEA standard GPS and Autopilot messages, and uses the GPS for localization. It has a PID loop controlling each motor, and the parameters for the rudder PID can be changed by the user in the UI. The system fulfills all requirements for the controller unit. 

The logic level shifter and step-down circuits used to power the Raspberry Pi, DC motor, and Servo work as intended, and decouple the different components as desired. The high currents seen when testing the DC motor initially were managed properly with the driver circuit, and none of the other components were negatively impacted. Finally, the Raspberry Pi 3b provided the desired functionality at an affordable price, and had enough documentation (and available libraries) to make setup and verification of the PWM outputs relatively painless. 